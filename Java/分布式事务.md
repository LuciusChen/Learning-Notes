事务的四大特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称 ACID。

在单体架构时代，所有的业务只用一个数据库，利用数据库本身提供的事务机制支持就可以。例如 MySQL 数据库：事务的隔离性是通过数据库锁的机现的。事务的一致性由「undo log」来保证：「undo log」是逻辑日志，记录了事务的`insert`、`update`、`delete`操作，回滚的时候做相反的`delete`、`update`、`insert`操作来恢复数据。事务的原子性和一持久性由「redo log」来制实保证：「redo log」被称作重做日志，是物理日志，事务提交的时候，必须先将事务的所有日志写入「redo log」持久化，到事务的提交操作才算完成。

## 分布式事务

![](/Java/images/Distributed%20transaction%20management.png)

### XA

[CAP](/Java/CAP.md) 理论，无法都满足，其中 P 是分布式的基础，只能根据实际情况在 C 和 A 中取舍，演化成 [BASE](/Java/CAP.md#BASE-理论) 理论。

「XA」是一个分布式事务协议，由「Tuxedo」提出。在这个协议里，有三个角色：AP（Application）：应用系统（服务）、TM（Transaction Manager）：事务管理器（全局事务管理）、RM（Resource Manager）：资源管理器（数据库）。XA 规范主要定义了事务管理器（Transaction Manager）和资源管理器（Resource Manager）之间的接口。

![](/Java/images/XA.png)

「XA」协议采用「两阶段提交」方式来管理分布式事务。「XA」接口提供资源管理器与事务管理器之间进行通信的标准接口。

#### 2PC 两阶段提交

两阶段提交的思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况决定各参与者是否要提交操作还是中止操作。

![](/Java/images/2PC.jpeg)

两阶段提交优点：尽量保证了数据的强一致，但不是100%一致。

两阶段提交同样有一些缺点：
- 单点故障 
  由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞，尤其时在第二阶段，协调者发生故障，那么所有的参与者都处于锁定事务资源的状态中，而无法继续完成事务操作。 
- 同步阻塞 
  它是一个强一致性的同步阻塞协议，也就是所谓刚性事务，事务执⾏过程中需要将所需资源全部锁定，会比较影响性能。 
- 数据不一致 
  在第二阶段中，当协调者想参与者发送提交事务请求之后，由于网络抖动，如果第二阶段只有部分参与者收到提交请求，那么就会导致数据不一致。

#### 3PC 三阶段提交

三阶段提交「3PC」是二阶段提交「2PC」的一种改进版本 ，为解决两阶段提交协议的单点故障和同步阻塞问题。上边提到两阶段提交，当协调者崩溃时，参与者不能做出最后的选择，就会一直保持阻塞锁定资源。「2PC」中只有协调者有超时机制，「3PC」在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。而且在第一阶段和第二阶段中又插入了一个预提交阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。

### SAGA

Saga是这一篇数据库论文saga提到的一个方案。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

把转账作为例子，一个成功完成的SAGA事务时序图如下：

![](/Java/images/SAGA.jpeg)

SAGA 事务的特点：

  - 并发度高，不用像XA事务那样长期锁定资源
  - 需要定义正常操作以及补偿操作，开发量比 XA 大
  - 一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况

论文里面的 SAGA 内容较多，包括两种恢复策略，包括分支事务并发执行，我们这里的讨论，仅包括最简单的 SAGA。

SAGA 适用的场景较多，长事务适用，对中间结果不敏感的业务场景适用

### TCC

关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。

TCC分为3个阶段：

  - Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）
  - Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作要求具备幂等设计，Confirm 失败后需要进行重试。
  - Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致，要求满足幂等设计。
  拿转账作为例子，通常会在 Try 里面冻结金额，但不扣款，Confirm 里面扣款，Cancel 里面解冻金额，一个成功完成的 TCC 事务时序图如下：
  
  ![](/Java/images/TCC.jpeg)

TCC 特点如下：

  - 并发度较高，无长期资源锁定。
  - 开发量较大，需要提供 Try/Confirm/Cancel 接口。
  - 一致性较好，不会发生 SAGA 已扣款最后又转账失败的情况
  - TCC 适用于订单类业务，对中间状态有约束的业务

### 本地消息表（Local Messaging）